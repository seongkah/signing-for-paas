#!/usr/bin/env node

/**
 * Complete TikTok Live Protobuf WebSocket Pipeline Test
 * 
 * This tests the COMPLETE reverse engineering flow:
 * 1. Use your signing service to get authentication data
 * 2. Establish WebSocket connection to TikTok's servers
 * 3. Decode protobuf messages from the live stream
 * 4. Parse events (chat, gifts, etc.)
 * 
 * This is the REAL test of whether your signing service works
 * for the complete TikTok Live reverse engineering pipeline.
 */

const config = require('./tiktok-signing.config.js');

class ProtobufWebSocketTest {
  constructor(username) {
    this.username = username;
    this.stats = {
      signatureTime: null,
      websocketConnected: false,
      protobufMessages: 0,
      chatMessages: 0,
      giftEvents: 0,
      errors: []
    };
  }

  async runCompleteTest() {
    console.log('üî¨ Complete TikTok Live Protobuf WebSocket Pipeline Test');
    console.log('=' .repeat(60));
    console.log('');
    console.log('This tests the COMPLETE reverse engineering flow:');
    console.log('  1. üîê Authentication via your signing service');
    console.log('  2. üåê WebSocket connection to TikTok servers');
    console.log('  3. üì° Protobuf message reception and decoding');
    console.log('  4. üéØ Live event parsing (chat, gifts, etc.)');
    console.log('');
    
    // Step 1: Test Signing Service
    console.log('üîê STEP 1: Testing Your Signing Service');
    console.log('-'.repeat(40));
    
    const signatureData = await this.testSigningService();
    if (!signatureData) {
      console.log('‚ùå Signing service failed - cannot proceed');
      return false;
    }
    
    console.log('‚úÖ Signing service working - proceeding to WebSocket test');
    console.log('');
    
    // Step 2: Test Complete TikTok Live Connector Pipeline
    console.log('üåê STEP 2: Complete TikTok Live Connector Pipeline Test');
    console.log('-'.repeat(50));
    
    const pipelineResult = await this.testCompletePipeline();
    
    // Step 3: Results Analysis
    console.log('');
    console.log('üìä STEP 3: Pipeline Analysis');
    console.log('-'.repeat(30));
    this.analyzeResults();
    
    return pipelineResult;
  }

  async testSigningService() {
    console.log(`üé≠ Target user: @${this.username}`);
    console.log(`üîó Live URL: https://www.tiktok.com/@${this.username}/live`);
    
    // Get signing configuration
    const signingConfig = config.getSigningConfig();
    console.log('üîß Signing config generated:');
    console.log(`   Provider: ${signingConfig.signProvider}`);
    console.log(`   Has API Key: ${signingConfig.signProviderHeaders?.['X-API-Key'] ? '‚úÖ' : '‚ùå'}`);
    
    // Test the signing service API directly
    console.log('');
    console.log('üß™ Testing signature generation...');
    
    const startTime = Date.now();
    
    try {
      const https = require('https');
      const url = require('url');
      
      const testData = JSON.stringify({ 
        url: `https://www.tiktok.com/@${this.username}/live` 
      });
      
      const response = await new Promise((resolve, reject) => {
        const parsedUrl = url.parse(signingConfig.signProvider);
        
        const options = {
          hostname: parsedUrl.hostname,
          port: parsedUrl.port || 443,
          path: parsedUrl.path,
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...signingConfig.signProviderHeaders
          }
        };
        
        const req = https.request(options, (res) => {
          let data = '';
          res.on('data', chunk => data += chunk);
          res.on('end', () => {
            try {
              resolve({
                status: res.statusCode,
                data: JSON.parse(data),
                responseTime: Date.now() - startTime
              });
            } catch (e) {
              reject(new Error(`Invalid JSON: ${data.slice(0, 100)}`));
            }
          });
        });
        
        req.on('error', reject);
        req.setTimeout(15000, () => reject(new Error('Signature request timeout')));
        req.write(testData);
        req.end();
      });
      
      this.stats.signatureTime = response.responseTime;
      
      if (response.status === 200 && response.data.success) {
        console.log('‚úÖ Signature service SUCCESS:');
        console.log(`   Response time: ${response.responseTime}ms`);
        console.log(`   Signature: ${response.data.data.signature ? '‚úÖ Generated' : '‚ùå Missing'}`);
        console.log(`   X-Bogus: ${response.data.data['X-Bogus'] ? '‚úÖ Generated' : '‚ùå Missing'}`);
        console.log(`   Navigator data: ${response.data.data.navigator ? '‚úÖ Present' : '‚ùå Missing'}`);
        
        return response.data;
      } else {
        console.log('‚ùå Signature service FAILED:');
        console.log(`   Status: ${response.status}`);
        console.log(`   Error: ${response.data.error || 'Unknown'}`);
        return null;
      }
      
    } catch (error) {
      console.log('‚ùå Signature service ERROR:');
      console.log(`   ${error.message}`);
      this.stats.errors.push(`Signature: ${error.message}`);
      return null;
    }
  }

  async testCompletePipeline() {
    console.log('üîå Initializing TikTok Live Connector with your signing service...');
    
    try {
      const { TikTokLiveConnection } = require('tiktok-live-connector');
      
      // Create connection with your signing service
      const connection = new TikTokLiveConnection(this.username, config.getSigningConfig());
      
      console.log('‚úÖ TikTok Live Connector created with your signing config');
      
      // Set up comprehensive event monitoring
      this.setupEventMonitoring(connection);
      
      console.log('üéØ Attempting WebSocket connection...');
      console.log('   This will test the complete pipeline:');
      console.log('   - Your signature ‚Üí TikTok authentication');  
      console.log('   - WebSocket handshake');
      console.log('   - Protobuf message stream');
      console.log('   - Event decoding');
      console.log('');
      
      try {
        // Connect with timeout
        const connectPromise = connection.connect();
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Pipeline timeout after 20 seconds')), 20000)
        );
        
        const state = await Promise.race([connectPromise, timeoutPromise]);
        
        console.log('üéâ PIPELINE SUCCESS: Full connection established!');
        console.log('üì∫ Connection details:');
        console.log(`   Room ID: ${state.roomId}`);
        console.log(`   Status: ${state.liveStatus || 'Live'}`);
        console.log(`   Viewers: ${state.viewerCount || 'Unknown'}`);
        
        this.stats.websocketConnected = true;
        
        // Monitor the protobuf stream for 30 seconds
        console.log('');
        console.log('üì° Monitoring protobuf message stream...');
        console.log('   Waiting for live events (chat, gifts, etc.)...');
        console.log('   Duration: 30 seconds');
        console.log('-'.repeat(50));
        
        await this.monitorProtobufStream(30);
        
        // Disconnect
        connection.disconnect();
        
        return true;
        
      } catch (connectionError) {
        console.log('‚ùå PIPELINE FAILED at WebSocket connection:');
        console.log(`   Error: ${connectionError.message}`);
        
        this.analyzeConnectionFailure(connectionError);
        this.stats.errors.push(`WebSocket: ${connectionError.message}`);
        
        return false;
      }
      
    } catch (packageError) {
      console.log('‚ùå TikTok Live Connector package error:');
      console.log(`   ${packageError.message}`);
      console.log('üí° Install with: npm install tiktok-live-connector');
      return false;
    }
  }

  setupEventMonitoring(connection) {
    // WebSocket connection events
    connection.on('connected', (state) => {
      console.log('üü¢ WebSocket CONNECTED - protobuf stream active');
      this.stats.websocketConnected = true;
    });
    
    connection.on('disconnected', () => {
      console.log('üî¥ WebSocket DISCONNECTED - protobuf stream ended');
    });
    
    connection.on('error', (error) => {
      let errorMsg = 'Unknown error';
      try {
        errorMsg = error?.message || error?.toString?.() || JSON.stringify(error) || 'Unknown error';
      } catch (e) {
        errorMsg = 'Error processing error message';
      }
      console.log(`üö® Pipeline ERROR: ${errorMsg}`);
      this.stats.errors.push(`Pipeline: ${errorMsg}`);
    });
    
    // Try to handle protobuf events
    try {
      const { WebcastEvent } = require('tiktok-live-connector');
      
      // Chat messages (protobuf decoded)
      connection.on(WebcastEvent.CHAT, (data) => {
        this.stats.protobufMessages++;
        this.stats.chatMessages++;
        const timestamp = new Date().toLocaleTimeString();
        console.log(`üí¨ [${timestamp}] CHAT DECODED: ${data.user.uniqueId} ‚Üí ${data.comment}`);
      });
      
      // Gift events (protobuf decoded)
      connection.on(WebcastEvent.GIFT, (data) => {
        this.stats.protobufMessages++;
        this.stats.giftEvents++;
        const timestamp = new Date().toLocaleTimeString();
        const giftName = data.giftName || `Gift ${data.giftId}`;
        const diamonds = data.diamondCount > 0 ? ` (üíé${data.diamondCount})` : '';
        console.log(`üéÅ [${timestamp}] GIFT DECODED: ${data.user.uniqueId} ‚Üí ${giftName}${diamonds}`);
      });
      
      // Other protobuf events
      connection.on(WebcastEvent.LIKE, (data) => {
        this.stats.protobufMessages++;
        const timestamp = new Date().toLocaleTimeString();
        console.log(`‚ù§Ô∏è [${timestamp}] LIKE DECODED: ${data.user.uniqueId} (+${data.likeCount || 1})`);
      });
      
      connection.on(WebcastEvent.SOCIAL, (data) => {
        this.stats.protobufMessages++;
        const timestamp = new Date().toLocaleTimeString();
        console.log(`üë• [${timestamp}] SOCIAL DECODED: ${data.user.uniqueId} ${data.displayType}`);
      });
      
      connection.on(WebcastEvent.ROOM_USER, (data) => {
        const timestamp = new Date().toLocaleTimeString();
        console.log(`üìä [${timestamp}] ROOM UPDATE: ${data.viewerCount} viewers`);
      });
      
      // Raw protobuf message (if available)
      connection.on(WebcastEvent.STREAMDATA, (data) => {
        this.stats.protobufMessages++;
        console.log(`üì° RAW PROTOBUF: ${data.length} bytes received`);
      });
      
    } catch (e) {
      console.log('‚ö†Ô∏è Using fallback event handling (WebcastEvent not fully available)');
      
      // Fallback event handlers
      connection.on('chat', (data) => {
        this.stats.protobufMessages++;
        this.stats.chatMessages++;
        console.log(`üí¨ CHAT: ${data.user?.uniqueId || 'User'} ‚Üí ${data.comment}`);
      });
      
      connection.on('gift', (data) => {
        this.stats.protobufMessages++;
        this.stats.giftEvents++;
        console.log(`üéÅ GIFT: ${data.user?.uniqueId || 'User'} sent gift`);
      });
    }
  }

  async monitorProtobufStream(seconds) {
    const startTime = Date.now();
    
    return new Promise((resolve) => {
      const interval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        const remaining = seconds - elapsed;
        
        if (remaining <= 0) {
          clearInterval(interval);
          resolve();
          return;
        }
        
        // Show progress every 10 seconds if no activity
        if (elapsed > 0 && elapsed % 10 === 0) {
          console.log(`‚è≥ Monitoring... ${remaining}s left (${this.stats.protobufMessages} protobuf messages decoded)`);
        }
      }, 1000);
    });
  }

  analyzeConnectionFailure(error) {
    console.log('');
    console.log('üîç CONNECTION FAILURE ANALYSIS:');
    
    const errorMsg = error.message || error.toString();
    
    if (errorMsg.includes('403')) {
      console.log('   üìã 403 Forbidden - Authentication/Access Issue:');
      console.log('      ‚Ä¢ User might not be currently live');
      console.log('      ‚Ä¢ Stream might be private/restricted');
      console.log('      ‚Ä¢ Signature format might be incompatible');
      console.log('      ‚Ä¢ TikTok may have changed authentication requirements');
      
    } else if (errorMsg.includes('404')) {
      console.log('   üìã 404 Not Found - User/Stream Issue:');
      console.log('      ‚Ä¢ User does not exist');
      console.log('      ‚Ä¢ User is not live');
      console.log('      ‚Ä¢ Incorrect username format');
      
    } else if (errorMsg.includes('timeout')) {
      console.log('   üìã Timeout - Network/Server Issue:');
      console.log('      ‚Ä¢ Slow network connection');
      console.log('      ‚Ä¢ TikTok servers under load');
      console.log('      ‚Ä¢ Signature generation too slow');
      
    } else if (errorMsg.includes('websocket') || errorMsg.includes('WebSocket')) {
      console.log('   üìã WebSocket Issue - Protocol Problem:');
      console.log('      ‚Ä¢ WebSocket handshake failed');
      console.log('      ‚Ä¢ Signature not compatible with WebSocket auth');
      console.log('      ‚Ä¢ Network blocking WebSocket connections');
      
    } else {
      console.log('   üìã Unknown Issue:');
      console.log('      ‚Ä¢ TikTok may have changed their protocol');
      console.log('      ‚Ä¢ Network connectivity problems');
      console.log('      ‚Ä¢ Temporary server issues');
    }
    
    console.log('');
    console.log('üí° DEBUGGING STEPS:');
    console.log(`   1. Verify @${this.username} is live: https://www.tiktok.com/@${this.username}/live`);
    console.log('   2. Try a different username that is definitely live');
    console.log('   3. Test at different times of day');
    console.log('   4. Check if your IP/location is blocked');
  }

  analyzeResults() {
    console.log('üìä COMPLETE PIPELINE TEST RESULTS:');
    console.log('='.repeat(40));
    
    // Signing service results
    console.log('üîê Signing Service:');
    console.log(`   Response Time: ${this.stats.signatureTime || 'N/A'}ms`);
    console.log(`   Status: ${this.stats.signatureTime ? '‚úÖ Working' : '‚ùå Failed'}`);
    
    // WebSocket connection results
    console.log('');
    console.log('üåê WebSocket Connection:');
    console.log(`   Connected: ${this.stats.websocketConnected ? '‚úÖ Success' : '‚ùå Failed'}`);
    console.log(`   Authentication: ${this.stats.websocketConnected ? '‚úÖ Passed' : '‚ùå Failed'}`);
    
    // Protobuf decoding results
    console.log('');
    console.log('üì° Protobuf Message Decoding:');
    console.log(`   Total Messages: ${this.stats.protobufMessages}`);
    console.log(`   Chat Messages: ${this.stats.chatMessages}`);
    console.log(`   Gift Events: ${this.stats.giftEvents}`);
    console.log(`   Decoding Status: ${this.stats.protobufMessages > 0 ? '‚úÖ Working' : '‚ö†Ô∏è No data'}`);
    
    // Error summary
    console.log('');
    console.log('üö® Errors:');
    if (this.stats.errors.length === 0) {
      console.log('   ‚úÖ No errors detected');
    } else {
      this.stats.errors.forEach((error, i) => {
        console.log(`   ${i + 1}. ${error}`);
      });
    }
    
    // Overall assessment
    console.log('');
    console.log('üéØ OVERALL ASSESSMENT:');
    if (this.stats.websocketConnected && this.stats.protobufMessages > 0) {
      console.log('   üü¢ COMPLETE SUCCESS: Full pipeline working!');
      console.log('   ‚úÖ Your signing service enables complete TikTok Live reverse engineering');
      console.log('   ‚úÖ Ready for production use');
      
    } else if (this.stats.websocketConnected) {
      console.log('   üü° PARTIAL SUCCESS: Connection works, limited activity');
      console.log('   ‚úÖ Your signing service works for WebSocket connection');
      console.log('   ‚ö†Ô∏è User might not be very active or live stream is quiet');
      
    } else if (this.stats.signatureTime) {
      console.log('   üü† SIGNING WORKS: WebSocket connection issues');
      console.log('   ‚úÖ Your signing service generates valid signatures');
      console.log('   ‚ùå WebSocket connection failed (likely user not live)');
      console.log('   üí° Try with a different active live streamer');
      
    } else {
      console.log('   üî¥ CRITICAL: Signing service not working');
      console.log('   ‚ùå Basic signature generation failed');
      console.log('   üîß Check your configuration and API key');
    }
  }
}

// Main execution
async function main() {
  const username = process.argv[2];
  
  if (!username) {
    console.log('üî¨ TikTok Live Protobuf WebSocket Pipeline Test');
    console.log('');
    console.log('This tests the COMPLETE reverse engineering pipeline:');
    console.log('  Signing Service ‚Üí WebSocket ‚Üí Protobuf ‚Üí Live Events');
    console.log('');
    console.log('Usage: node protobuf-websocket-test.js <username>');
    console.log('');
    console.log('Examples:');
    console.log('  node protobuf-websocket-test.js kuian888');
    console.log('  node protobuf-websocket-test.js officialgeilegisela');
    console.log('');
    console.log('üí° Important: Use a username that is CURRENTLY LIVE');
    console.log('   Check https://www.tiktok.com/@username/live first');
    console.log('');
    process.exit(1);
  }
  
  const test = new ProtobufWebSocketTest(username);
  
  // Handle interruption
  process.on('SIGINT', () => {
    console.log('\\nüõë Test interrupted by user');
    test.analyzeResults();
    process.exit(0);
  });
  
  console.log('üöÄ Starting complete pipeline test...');
  console.log('This will test the ENTIRE reverse engineering flow!');
  console.log('');
  
  const success = await test.runCompleteTest();
  
  console.log('');
  console.log('üèÅ PIPELINE TEST COMPLETE!');
  
  process.exit(success ? 0 : 1);
}

main().catch(error => {
  console.error('üí• Pipeline test crashed:', error.message);
  console.error('This indicates a serious issue with the setup');
  process.exit(1);
});