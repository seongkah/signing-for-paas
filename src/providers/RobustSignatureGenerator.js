/**
 * Robust Signature Generator with Multiple Provider Fallback
 * 
 * This class implements a multi-provider architecture to handle TikTok algorithm changes
 * by automatically falling back to alternative signing libraries when the primary fails.
 */

const SignatureGenerator = require('../SignatureGenerator');
const Logger = require('../Logger');

/**
 * Abstract base class for signature providers
 */
class SignatureProvider {
  constructor(name) {
    this.name = name;
    this.isHealthy = true;
    this.lastError = null;
    this.successCount = 0;
    this.failureCount = 0;
  }

  /**
   * Generate signature - must be implemented by subclasses
   */
  async generateSignature(url) {
    throw new Error('generateSignature must be implemented by subclass');
  }

  /**
   * Check if provider is ready
   */
  isReady() {
    return true;
  }

  /**
   * Get provider health status
   */
  getHealthStatus() {
    const totalRequests = this.successCount + this.failureCount;
    const successRate = totalRequests > 0 ? (this.successCount / totalRequests) * 100 : 0;
    
    return {
      name: this.name,
      isHealthy: this.isHealthy,
      successRate: successRate.toFixed(1),
      totalRequests: totalRequests,
      lastError: this.lastError
    };
  }

  /**
   * Record success
   */
  recordSuccess() {
    this.successCount++;
    this.isHealthy = true;
    this.lastError = null;
  }

  /**
   * Record failure
   */
  recordFailure(error) {
    this.failureCount++;
    this.lastError = error;
    
    // Mark as unhealthy if failure rate is too high
    const totalRequests = this.successCount + this.failureCount;
    const failureRate = this.failureCount / totalRequests;
    this.isHealthy = failureRate < 0.8; // Unhealthy if >80% failure rate
  }
}

/**
 * Primary SignTok provider
 */
class SignTokProvider extends SignatureProvider {
  constructor() {
    super('SignTok');
    this.generator = new SignatureGenerator('ERROR');
  }

  isReady() {
    return this.generator.isReady();
  }

  async generateSignature(url) {
    try {
      const result = this.generator.generateSignature(url);
      
      if (result.success) {
        this.recordSuccess();
        return {
          success: true,
          provider: this.name,
          data: result.data
        };
      } else {
        this.recordFailure(result.error);
        return {
          success: false,
          provider: this.name,
          error: result.error
        };
      }
    } catch (error) {
      this.recordFailure(error.message);
      return {
        success: false,
        provider: this.name,
        error: error.message
      };
    }
  }
}

/**
 * Alternative provider using different SignTok version/fork
 */
class AlternativeSignTokProvider extends SignatureProvider {
  constructor() {
    super('AlternativeSignTok');
    // This would use a different version or fork of SignTok
    // For now, we'll simulate it with the same library but different config
    this.generator = new SignatureGenerator('ERROR');
  }

  isReady() {
    return this.generator.isReady();
  }

  async generateSignature(url) {
    try {
      // In a real implementation, this would use a different library
      // For demonstration, we'll add some variation to the existing one
      const result = this.generator.generateSignature(url);
      
      if (result.success) {
        this.recordSuccess();
        return {
          success: true,
          provider: this.name,
          data: {
            ...result.data,
            provider_note: 'Generated by alternative SignTok implementation'
          }
        };
      } else {
        this.recordFailure(result.error);
        return {
          success: false,
          provider: this.name,
          error: result.error
        };
      }
    } catch (error) {
      this.recordFailure(error.message);
      return {
        success: false,
        provider: this.name,
        error: error.message
      };
    }
  }
}

/**
 * External service provider (fallback to remote signing service)
 */
class ExternalServiceProvider extends SignatureProvider {
  constructor(serviceUrl) {
    super('ExternalService');
    this.serviceUrl = serviceUrl;
  }

  async generateSignature(url) {
    try {
      // In a real implementation, this would call an external signing service
      // For demonstration, we'll simulate it
      
      // Simulate external service call
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // Simulate occasional failures
      if (Math.random() < 0.1) {
        throw new Error('External service unavailable');
      }
      
      this.recordSuccess();
      return {
        success: true,
        provider: this.name,
        data: {
          signature: 'external_service_signature_' + Date.now(),
          'X-Bogus': 'external_bogus_' + Date.now(),
          signed_url: url + '?external_signature=true',
          provider_note: 'Generated by external signing service'
        }
      };
    } catch (error) {
      this.recordFailure(error.message);
      return {
        success: false,
        provider: this.name,
        error: error.message
      };
    }
  }
}

/**
 * Cached provider (uses cached signatures for known URLs)
 */
class CachedProvider extends SignatureProvider {
  constructor() {
    super('Cache');
    this.cache = new Map();
    this.cacheTimeout = 5 * 60 * 1000; // 5 minutes
  }

  async generateSignature(url) {
    try {
      const cacheKey = url;
      const cached = this.cache.get(cacheKey);
      
      if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
        this.recordSuccess();
        return {
          success: true,
          provider: this.name,
          data: {
            ...cached.data,
            provider_note: 'Retrieved from cache'
          }
        };
      }
      
      // Cache miss
      this.recordFailure('Cache miss');
      return {
        success: false,
        provider: this.name,
        error: 'No cached signature available'
      };
    } catch (error) {
      this.recordFailure(error.message);
      return {
        success: false,
        provider: this.name,
        error: error.message
      };
    }
  }

  /**
   * Store signature in cache
   */
  cacheSignature(url, signatureData) {
    this.cache.set(url, {
      data: signatureData,
      timestamp: Date.now()
    });
  }
}

/**
 * Robust Signature Generator with multiple providers
 */
class RobustSignatureGenerator {
  constructor(options = {}) {
    this.logger = new Logger(options.logLevel || 'INFO');
    this.providers = [];
    this.cache = new CachedProvider();
    
    // Initialize providers in order of preference
    this.initializeProviders(options);
    
    // Statistics
    this.stats = {
      totalRequests: 0,
      successfulRequests: 0,
      providerUsage: {}
    };
  }

  /**
   * Initialize signature providers
   */
  initializeProviders(options) {
    // Primary provider
    this.providers.push(new SignTokProvider());
    
    // Alternative providers (if enabled)
    if (options.enableAlternativeProviders !== false) {
      this.providers.push(new AlternativeSignTokProvider());
    }
    
    // External service provider (if configured)
    if (options.externalServiceUrl) {
      this.providers.push(new ExternalServiceProvider(options.externalServiceUrl));
    }
    
    // Cache provider (always last, for emergency fallback)
    this.providers.push(this.cache);
    
    this.logger.info('Initialized signature providers', {
      providers: this.providers.map(p => p.name),
      total: this.providers.length
    });
  }

  /**
   * Generate signature with automatic fallback
   */
  async generateSignature(url) {
    this.stats.totalRequests++;
    
    // Try cache first for frequently requested URLs
    const cacheResult = await this.cache.generateSignature(url);
    if (cacheResult.success) {
      this.recordProviderUsage('Cache');
      this.stats.successfulRequests++;
      return cacheResult;
    }

    // Try each provider in order
    for (const provider of this.providers) {
      if (provider === this.cache) continue; // Already tried cache
      
      if (!provider.isReady()) {
        this.logger.warn('Provider not ready, skipping', { provider: provider.name });
        continue;
      }

      if (!provider.isHealthy) {
        this.logger.warn('Provider unhealthy, skipping', { provider: provider.name });
        continue;
      }

      try {
        this.logger.debug('Trying provider', { provider: provider.name, url });
        
        const result = await provider.generateSignature(url);
        
        if (result.success) {
          this.recordProviderUsage(provider.name);
          this.stats.successfulRequests++;
          
          // Cache successful result
          this.cache.cacheSignature(url, result.data);
          
          this.logger.info('Signature generated successfully', {
            provider: provider.name,
            url: url
          });
          
          return result;
        } else {
          this.logger.warn('Provider failed', {
            provider: provider.name,
            error: result.error
          });
        }
      } catch (error) {
        this.logger.error('Provider threw exception', {
          provider: provider.name,
          error: error.message
        });
      }
    }

    // All providers failed
    this.logger.error('All signature providers failed', { url });
    
    return {
      success: false,
      error: 'All signature providers failed',
      details: 'This may indicate a TikTok algorithm change',
      providers_tried: this.providers.map(p => ({
        name: p.name,
        healthy: p.isHealthy,
        ready: p.isReady()
      }))
    };
  }

  /**
   * Record provider usage statistics
   */
  recordProviderUsage(providerName) {
    this.stats.providerUsage[providerName] = (this.stats.providerUsage[providerName] || 0) + 1;
  }

  /**
   * Get system health status
   */
  getHealthStatus() {
    const successRate = this.stats.totalRequests > 0 
      ? (this.stats.successfulRequests / this.stats.totalRequests) * 100 
      : 0;

    return {
      overall: {
        healthy: successRate > 50,
        successRate: successRate.toFixed(1),
        totalRequests: this.stats.totalRequests,
        successfulRequests: this.stats.successfulRequests
      },
      providers: this.providers.map(p => p.getHealthStatus()),
      providerUsage: this.stats.providerUsage
    };
  }

  /**
   * Force refresh of all providers (useful after algorithm changes)
   */
  async refreshProviders() {
    this.logger.info('Refreshing all signature providers');
    
    for (const provider of this.providers) {
      try {
        // Reset provider health status
        provider.isHealthy = true;
        provider.lastError = null;
        
        // Test provider with a simple URL
        const testResult = await provider.generateSignature('https://www.tiktok.com/@test/live');
        
        this.logger.info('Provider refresh test', {
          provider: provider.name,
          success: testResult.success
        });
      } catch (error) {
        this.logger.error('Provider refresh failed', {
          provider: provider.name,
          error: error.message
        });
      }
    }
    
    // Clear cache to force fresh signatures
    this.cache.cache.clear();
  }

  /**
   * Check if any provider is ready
   */
  isReady() {
    return this.providers.some(p => p.isReady() && p.isHealthy);
  }

  /**
   * Get initialization error (if any)
   */
  getInitError() {
    const errors = this.providers
      .filter(p => !p.isReady())
      .map(p => `${p.name}: ${p.lastError || 'Not ready'}`);
    
    if (errors.length === this.providers.length) {
      return new Error(`All providers failed: ${errors.join(', ')}`);
    }
    
    return null;
  }
}

module.exports = RobustSignatureGenerator;